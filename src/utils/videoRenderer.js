/**
 * VideoRenderer - SOLUCIONADO para visualizaci√≥n de video
 * 
 * PROBLEMA IDENTIFICADO: Los elementos de video no se estaban configurando correctamente
 * SOLUCI√ìN: Simplificar y asegurar que los streams se asignen directamente a los elementos video
 * 
 * @author SecureCall Team
 * @version 2.0.0 - FIXED
 */

class VideoRenderer {
  constructor() {
    this.localVideoElement = null;
    this.remoteVideoElement = null;
    this.isLocalRendering = false;
    this.isRemoteRendering = false;
    this.frameStats = {
      localFrames: 0,
      remoteFrames: 0,
      lastLocalRender: 0,
      lastRemoteRender: 0
    };
    this.debugMode = true;
    
    // üîß FIXED: Canvas para Socket.IO streaming
    this.remoteCanvas = null;
    this.remoteCanvasStream = null;
  }

  _log(message, level = 'info') {
    if (this.debugMode) {
      const timestamp = new Date().toISOString();
      console[level](`[VideoRenderer ${timestamp}] ${message}`);
    }
  }

  /**
   * üéØ SOLUCIONADO: Inicializar video local (usuario se ve a s√≠ mismo)
   * PROBLEMA: El stream no se asignaba correctamente al elemento video
   * SOLUCI√ìN: Asignaci√≥n directa y verificaci√≥n de reproducci√≥n
   */
  initializeLocalVideoRenderer(videoElement, stream) {
    try {
      this._log('üé• FIXED: Initializing local video renderer...');
      
      if (!videoElement) {
        throw new Error('Local video element is required');
      }
      
      if (!stream) {
        throw new Error('Local stream is required');
      }

      this.localVideoElement = videoElement;
      
      // üîß FIXED: Asignaci√≥n directa y simple del stream
      this._log('üì∫ FIXED: Assigning stream directly to local video element');
      this.localVideoElement.srcObject = stream;
      this.localVideoElement.muted = true; // CR√çTICO: evitar feedback
      this.localVideoElement.autoplay = true;
      this.localVideoElement.playsInline = true;
      
      // üîß FIXED: Forzar reproducci√≥n inmediata
      const playPromise = this.localVideoElement.play();
      
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            this._log('‚úÖ FIXED: Local video is now playing and visible');
            this.isLocalRendering = true;
            this.frameStats.lastLocalRender = Date.now();
            this.frameStats.localFrames++;
          })
          .catch(error => {
            this._log(`‚ùå FIXED: Local video play failed: ${error.message}`, 'error');
            // Intentar reproducir de nuevo despu√©s de un momento
            setTimeout(() => {
              this.localVideoElement.play().catch(console.error);
            }, 1000);
          });
      }

      // üîß FIXED: Verificar que el video tiene dimensiones
      this.localVideoElement.onloadedmetadata = () => {
        this._log(`‚úÖ FIXED: Local video metadata loaded - ${this.localVideoElement.videoWidth}x${this.localVideoElement.videoHeight}`);
        
        // Asegurar que el video se est√° reproduciendo
        if (this.localVideoElement.paused) {
          this.localVideoElement.play().catch(console.error);
        }
      };

      this._log('‚úÖ FIXED: Local video renderer initialized successfully');
      return { success: true, method: 'direct-stream-assignment' };

    } catch (error) {
      this._log(`‚ùå FIXED: Error in local video renderer: ${error.message}`, 'error');
      throw error;
    }
  }

  /**
   * üéØ SOLUCIONADO: Inicializar video remoto para Socket.IO streaming
   * PROBLEMA: El canvas no se configuraba correctamente para mostrar frames
   * SOLUCI√ìN: Canvas stream directo al elemento video
   */
  initializeRemoteVideoRenderer(videoElement) {
    try {
      this._log('üñºÔ∏è FIXED: Initializing remote video renderer...');
      
      if (!videoElement) {
        throw new Error('Remote video element is required');
      }

      this.remoteVideoElement = videoElement;

      // üîß FIXED: Crear canvas para renderizar frames de Socket.IO
      this.remoteCanvas = document.createElement('canvas');
      this.remoteCanvas.width = 640;
      this.remoteCanvas.height = 480;
      this.remoteCanvas.style.display = 'none'; // Oculto, solo para captura
      document.body.appendChild(this.remoteCanvas);

      // üîß FIXED: Crear stream desde canvas con FPS adecuado
      this.remoteCanvasStream = this.remoteCanvas.captureStream(15); // 15 FPS
      
      // üîß FIXED: Asignar stream del canvas al video element
      this.remoteVideoElement.srcObject = this.remoteCanvasStream;
      this.remoteVideoElement.autoplay = true;
      this.remoteVideoElement.playsInline = true;

      // üîß FIXED: Asegurar reproducci√≥n
      const playPromise = this.remoteVideoElement.play();
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            this._log('‚úÖ FIXED: Remote video canvas stream is playing');
            this.isRemoteRendering = true;
          })
          .catch(error => {
            this._log(`‚ùå FIXED: Remote video play failed: ${error.message}`, 'error');
          });
      }

      // üîß FIXED: Dibujar frame inicial para activar el stream
      const ctx = this.remoteCanvas.getContext('2d');
      if (ctx) {
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, this.remoteCanvas.width, this.remoteCanvas.height);
        ctx.fillStyle = '#ffffff';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Waiting for remote video...', this.remoteCanvas.width / 2, this.remoteCanvas.height / 2);
      }

      this._log('‚úÖ FIXED: Remote video renderer initialized successfully');
      return { success: true, canvas: this.remoteCanvas };

    } catch (error) {
      this._log(`‚ùå FIXED: Error in remote video renderer: ${error.message}`, 'error');
      throw error;
    }
  }

  /**
   * üéØ SOLUCIONADO: Renderizar frame remoto
   * PROBLEMA: Los frames no se dibujaban correctamente en el canvas
   * SOLUCI√ìN: Renderizado directo con manejo de aspect ratio
   */
  async renderRemoteFrame(frameData) {
    try {
      if (!this.isRemoteRendering || !this.remoteCanvas) {
        this._log('‚ö†Ô∏è FIXED: Remote renderer not ready, initializing...');
        return false;
      }

      if (!frameData || !frameData.startsWith('data:image/')) {
        this._log('‚ö†Ô∏è FIXED: Invalid frame data received');
        return false;
      }

      const ctx = this.remoteCanvas.getContext('2d');
      if (!ctx) {
        this._log('‚ùå FIXED: Cannot get canvas context');
        return false;
      }

      return new Promise((resolve) => {
        const img = new Image();
        
        img.onload = () => {
          try {
            // üîß FIXED: Limpiar canvas completamente
            ctx.clearRect(0, 0, this.remoteCanvas.width, this.remoteCanvas.height);
            
            // üîß FIXED: Dibujar imagen manteniendo aspect ratio
            const canvasAspect = this.remoteCanvas.width / this.remoteCanvas.height;
            const imageAspect = img.width / img.height;
            
            let drawWidth, drawHeight, drawX, drawY;
            
            if (imageAspect > canvasAspect) {
              // Imagen m√°s ancha - ajustar por ancho
              drawWidth = this.remoteCanvas.width;
              drawHeight = drawWidth / imageAspect;
              drawX = 0;
              drawY = (this.remoteCanvas.height - drawHeight) / 2;
            } else {
              // Imagen m√°s alta - ajustar por altura
              drawHeight = this.remoteCanvas.height;
              drawWidth = drawHeight * imageAspect;
              drawX = (this.remoteCanvas.width - drawWidth) / 2;
              drawY = 0;
            }
            
            // üîß FIXED: Dibujar con fondo negro para √°reas no cubiertas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, this.remoteCanvas.width, this.remoteCanvas.height);
            
            // üîß FIXED: Dibujar imagen
            ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
            
            // üîß FIXED: Actualizar estad√≠sticas
            this.frameStats.remoteFrames++;
            this.frameStats.lastRemoteRender = Date.now();

            // Log cada 30 frames para no saturar consola
            if (this.frameStats.remoteFrames % 30 === 0) {
              this._log(`‚úÖ FIXED: Rendered ${this.frameStats.remoteFrames} remote frames`);
            }

            resolve(true);
          } catch (drawError) {
            this._log(`‚ùå FIXED: Error drawing frame: ${drawError.message}`, 'error');
            resolve(false);
          }
        };

        img.onerror = () => {
          this._log(`‚ùå FIXED: Error loading frame image`, 'error');
          resolve(false);
        };

        // üîß FIXED: Cargar imagen
        img.src = frameData;
      });

    } catch (error) {
      this._log(`‚ùå FIXED: Error in renderRemoteFrame: ${error.message}`, 'error');
      return false;
    }
  }

  /**
   * üîß DIAGN√ìSTICO MEJORADO: Verificar estado completo
   */
  diagnoseRenderingIssues() {
    const diagnosis = {
      timestamp: new Date().toISOString(),
      localVideo: {
        element: !!this.localVideoElement,
        inDOM: this.localVideoElement ? document.contains(this.localVideoElement) : false,
        hasStream: !!(this.localVideoElement && this.localVideoElement.srcObject),
        isPlaying: !!(this.localVideoElement && !this.localVideoElement.paused),
        readyState: this.localVideoElement ? this.localVideoElement.readyState : 'N/A',
        videoWidth: this.localVideoElement ? this.localVideoElement.videoWidth : 0,
        videoHeight: this.localVideoElement ? this.localVideoElement.videoHeight : 0,
        currentTime: this.localVideoElement ? this.localVideoElement.currentTime : 0,
        muted: this.localVideoElement ? this.localVideoElement.muted : false
      },
      remoteVideo: {
        element: !!this.remoteVideoElement,
        inDOM: this.remoteVideoElement ? document.contains(this.remoteVideoElement) : false,
        hasStream: !!(this.remoteVideoElement && this.remoteVideoElement.srcObject),
        isPlaying: !!(this.remoteVideoElement && !this.remoteVideoElement.paused),
        readyState: this.remoteVideoElement ? this.remoteVideoElement.readyState : 'N/A',
        videoWidth: this.remoteVideoElement ? this.remoteVideoElement.videoWidth : 0,
        videoHeight: this.remoteVideoElement ? this.remoteVideoElement.videoHeight : 0
      },
      canvas: {
        remoteCanvas: !!this.remoteCanvas,
        remoteCanvasInDOM: this.remoteCanvas ? document.contains(this.remoteCanvas) : false,
        remoteCanvasSize: this.remoteCanvas ? `${this.remoteCanvas.width}x${this.remoteCanvas.height}` : 'N/A',
        hasCanvasStream: !!this.remoteCanvasStream
      },
      rendering: {
        isLocalRendering: this.isLocalRendering,
        isRemoteRendering: this.isRemoteRendering,
        localFrames: this.frameStats.localFrames,
        remoteFrames: this.frameStats.remoteFrames,
        timeSinceLastLocal: this.frameStats.lastLocalRender ? Date.now() - this.frameStats.lastLocalRender : 'Never',
        timeSinceLastRemote: this.frameStats.lastRemoteRender ? Date.now() - this.frameStats.lastRemoteRender : 'Never'
      }
    };

    this._log('üîç FIXED: COMPLETE RENDERING DIAGNOSIS:');
    this._log(JSON.stringify(diagnosis, null, 2));

    return diagnosis;
  }

  /**
   * üîß REPARACI√ìN MEJORADA: Arreglar problemas espec√≠ficos
   */
  attemptRenderingRepair() {
    this._log('üîß FIXED: Attempting comprehensive rendering repair...');

    const diagnosis = this.diagnoseRenderingIssues();
    const repairs = [];

    // üîß FIXED: Reparar video local
    if (diagnosis.localVideo.element && diagnosis.localVideo.hasStream) {
      if (!diagnosis.localVideo.isPlaying) {
        this._log('üîß FIXED: Repairing local video playback...');
        this.localVideoElement.play()
          .then(() => {
            this._log('‚úÖ FIXED: Local video playback repaired');
            this.isLocalRendering = true;
          })
          .catch(error => {
            this._log(`‚ùå FIXED: Local video repair failed: ${error.message}`, 'error');
          });
        repairs.push('local-video-play');
      }

      if (diagnosis.localVideo.readyState < 2) {
        this._log('üîß FIXED: Local video not ready, forcing reload...');
        const currentStream = this.localVideoElement.srcObject;
        this.localVideoElement.srcObject = null;
        setTimeout(() => {
          this.localVideoElement.srcObject = currentStream;
          this.localVideoElement.play().catch(console.error);
        }, 100);
        repairs.push('local-video-reload');
      }
    }

    // üîß FIXED: Reparar video remoto
    if (diagnosis.remoteVideo.element) {
      if (!diagnosis.remoteVideo.isPlaying && diagnosis.remoteVideo.hasStream) {
        this._log('üîß FIXED: Repairing remote video playback...');
        this.remoteVideoElement.play()
          .then(() => {
            this._log('‚úÖ FIXED: Remote video playback repaired');
          })
          .catch(error => {
            this._log(`‚ùå FIXED: Remote video repair failed: ${error.message}`, 'error');
          });
        repairs.push('remote-video-play');
      }

      // üîß FIXED: Recrear canvas stream si es necesario
      if (!diagnosis.canvas.hasCanvasStream && this.remoteCanvas) {
        this._log('üîß FIXED: Recreating remote canvas stream...');
        this.remoteCanvasStream = this.remoteCanvas.captureStream(15);
        this.remoteVideoElement.srcObject = this.remoteCanvasStream;
        this.remoteVideoElement.play().catch(console.error);
        repairs.push('remote-canvas-stream');
      }
    }

    // üîß FIXED: Reparar canvas remoto
    if (!diagnosis.canvas.remoteCanvasInDOM && this.remoteCanvas) {
      this._log('üîß FIXED: Re-adding remote canvas to DOM...');
      document.body.appendChild(this.remoteCanvas);
      repairs.push('remote-canvas-dom');
    }

    this._log(`‚úÖ FIXED: Repair completed. Applied repairs: ${repairs.join(', ')}`);
    return repairs;
  }

  /**
   * üß™ TEST VISUAL MEJORADO: Crear test completo
   */
  createVisualTest(container) {
    this._log('üß™ FIXED: Creating comprehensive visual test...');

    const testContainer = document.createElement('div');
    testContainer.style.cssText = `
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10000;
      background: rgba(0,0,0,0.9);
      padding: 15px;
      border-radius: 8px;
      color: white;
      font-family: monospace;
      font-size: 12px;
      max-width: 400px;
      border: 2px solid #00ff00;
    `;

    testContainer.innerHTML = '<h3 style="margin:0 0 10px 0; color:#00ff00;">üß™ VideoRenderer Test Panel</h3>';

    // üîß FIXED: Test de video local
    const localTest = document.createElement('div');
    localTest.style.marginBottom = '10px';
    localTest.innerHTML = `
      <strong>üìπ Local Video:</strong><br>
      Element: ${!!this.localVideoElement ? '‚úÖ' : '‚ùå'}<br>
      Stream: ${this.localVideoElement && this.localVideoElement.srcObject ? '‚úÖ' : '‚ùå'}<br>
      Playing: ${this.localVideoElement && !this.localVideoElement.paused ? '‚úÖ' : '‚ùå'}<br>
      Rendering: ${this.isLocalRendering ? '‚úÖ' : '‚ùå'}
    `;
    testContainer.appendChild(localTest);

    // üîß FIXED: Test de video remoto
    const remoteTest = document.createElement('div');
    remoteTest.style.marginBottom = '10px';
    remoteTest.innerHTML = `
      <strong>üì∫ Remote Video:</strong><br>
      Element: ${!!this.remoteVideoElement ? '‚úÖ' : '‚ùå'}<br>
      Canvas: ${!!this.remoteCanvas ? '‚úÖ' : '‚ùå'}<br>
      Stream: ${!!this.remoteCanvasStream ? '‚úÖ' : '‚ùå'}<br>
      Rendering: ${this.isRemoteRendering ? '‚úÖ' : '‚ùå'}<br>
      Frames: ${this.frameStats.remoteFrames}
    `;
    testContainer.appendChild(remoteTest);

    // üîß FIXED: Botones de acci√≥n
    const buttonContainer = document.createElement('div');
    buttonContainer.style.marginTop = '10px';

    const diagButton = document.createElement('button');
    diagButton.textContent = 'üîç Diagnose';
    diagButton.style.cssText = 'margin: 2px; padding: 5px; background: #333; color: white; border: 1px solid #666; border-radius: 3px; cursor: pointer;';
    diagButton.onclick = () => {
      const diagnosis = this.diagnoseRenderingIssues();
      alert('Diagnosis completed! Check console for details.');
    };

    const repairButton = document.createElement('button');
    repairButton.textContent = 'üîß Repair';
    repairButton.style.cssText = 'margin: 2px; padding: 5px; background: #333; color: white; border: 1px solid #666; border-radius: 3px; cursor: pointer;';
    repairButton.onclick = () => {
      const repairs = this.attemptRenderingRepair();
      alert(`Repairs applied: ${repairs.join(', ')}`);
      // Actualizar display
      setTimeout(() => {
        testContainer.remove();
        this.createVisualTest(container);
      }, 1000);
    };

    const closeButton = document.createElement('button');
    closeButton.textContent = '‚ùå Close';
    closeButton.style.cssText = 'margin: 2px; padding: 5px; background: #333; color: white; border: 1px solid #666; border-radius: 3px; cursor: pointer;';
    closeButton.onclick = () => testContainer.remove();

    buttonContainer.appendChild(diagButton);
    buttonContainer.appendChild(repairButton);
    buttonContainer.appendChild(closeButton);
    testContainer.appendChild(buttonContainer);

    // üîß FIXED: Agregar al contenedor
    if (container) {
      container.appendChild(testContainer);
    } else {
      document.body.appendChild(testContainer);
    }

    this._log('‚úÖ FIXED: Visual test panel created');
    return testContainer;
  }

  /**
   * üìä ESTAD√çSTICAS MEJORADAS
   */
  getStats() {
    return {
      ...this.frameStats,
      isLocalRendering: this.isLocalRendering,
      isRemoteRendering: this.isRemoteRendering,
      hasLocalCanvas: false, // No usamos canvas para local
      hasRemoteCanvas: !!this.remoteCanvas,
      localVideoReady: !!(this.localVideoElement && this.localVideoElement.readyState >= 2),
      remoteVideoReady: !!(this.remoteVideoElement && this.remoteVideoElement.readyState >= 2),
      localVideoPlaying: !!(this.localVideoElement && !this.localVideoElement.paused),
      remoteVideoPlaying: !!(this.remoteVideoElement && !this.remoteVideoElement.paused)
    };
  }

  /**
   * üßπ LIMPIEZA COMPLETA
   */
  cleanup() {
    this._log('üßπ FIXED: Cleaning up VideoRenderer...');

    // Detener renderizado
    this.isLocalRendering = false;
    this.isRemoteRendering = false;

    // Limpiar canvas remoto
    if (this.remoteCanvas && this.remoteCanvas.parentNode) {
      this.remoteCanvas.parentNode.removeChild(this.remoteCanvas);
    }
    this.remoteCanvas = null;
    this.remoteCanvasStream = null;

    // Reset referencias (sin limpiar los elementos, solo las referencias)
    this.localVideoElement = null;
    this.remoteVideoElement = null;

    // Reset estad√≠sticas
    this.frameStats = {
      localFrames: 0,
      remoteFrames: 0,
      lastLocalRender: 0,
      lastRemoteRender: 0
    };

    this._log('‚úÖ FIXED: VideoRenderer cleanup completed');
  }
}

export default VideoRenderer;